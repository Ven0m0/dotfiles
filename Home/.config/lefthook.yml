skip_output: [meta, execution]
output: [summary, skips]
colors: true
no_tty: false
min_version: 1.5.0
pre-commit:
  parallel: true
  piped: true
  commands:
    auto-stage:
      priority: 1
      run: git add -A
      skip: [{ run: 'LC_ALL=C git diff --cached --quiet', stage_fixed: false }]
    shell-format:
      priority: 2
      glob: '*.{sh,bash,zsh}'
      run: |
        shellcheck -x -a -s bash -S style -P SCRIPTDIR --norc -o all -f diff {staged_files} | patch -Np1 || :
        shellharden --replace {staged_files} || :
      stage_fixed: true
      fail_text: 'Shell formatting failed'
    yaml-format:
      priority: 3
      glob: '*.{yml,yaml}'
      run: |
        yamlfmt {staged_files} || :
        yamllint -f parsable {staged_files} || :
      stage_fixed: true
      fail_text: 'YAML formatting/linting failed'
    json-validate:
      priority: 4
      glob: '*.{json,jsonc,json5}'
      run: |
        for f in {staged_files}; do
          LC_ALL=C jaq -e . "$f" &>/dev/null || LC_ALL=C jq -e . "$f" || { printf "Invalid: %s\n" "$f" >&2; exit 1; }
        done
      fail_text: 'JSON validation failed'
    markdown-format:
      priority: 5
      glob: '*.md'
      run: |
        if command -v mdformat &>/dev/null; then
          mdformat {staged_files} || :
        elif command -v rumdl &>/dev/null; then
          rumdl check --fix {staged_files} || :
        elif command -v markdownlint-cli2 &>/dev/null; then
          markdownlint-cli2 --fix {staged_files} || :
        fi
      stage_fixed: true
      fail_text: 'Markdown formatting failed'
    js-format:
      priority: 6
      glob: '*.{js,ts,cjs,mjs,d.cts,d.mts,jsx,tsx,json,jsonc}'
      run: |
        if command -v biome &>/dev/null && [[ -r ${HOME}/.config/biome.json ]]; then
          BIOME_CONFIG_PATH="${HOME}/.config/biome.json" biome check --write --unsafe --skip-parse-errors {staged_files} || :
        elif command -v biome &>/dev/null; then
          BIOME_CONFIG_PATH="${HOME}/biome.json" biome check --write --unsafe --skip-parse-errors {staged_files} || :
        else
          bunx --bun @biomejs/biome check --write --no-errors-on-unmatched --files-ignore-unknown=true --colors=off {staged_files} || :
        fi
      stage_fixed: true
      fail_text: 'JavaScript/TypeScript formatting failed'
    prettier-format:
      priority: 7
      glob: '*.{mjs,cjs,scss,html}'
      run: 'prettier -w --ignore-unknown {staged_files} || :'
      stage_fixed: true
      fail_text: 'Prettier formatting failed'
    eslint-fix:
      priority: 8
      glob: '*.{js,jsx,ts,tsx,mjs,cjs}'
      run: 'eslint --fix -q {staged_files} || :'
      stage_fixed: true
      fail_text: 'ESLint fixes failed'
    trim-trailing:
      priority: 9
      glob: '*'
      exclude: "\\.(png|jpe?g|gif|webp|ico|svg|woff2?|ttf|eot|otf|mp[34]|webm|ogg|wav|flac|pdf|zip|tar|gz|xz|zst|bz2|7z|rar)$"
      run: |
        for f in {staged_files}; do
          [[ -f "$f" ]] && LC_ALL=C sed -i 's/[ \t]*$//' "$f"
        done
      stage_fixed: true
      fail_text: 'Trailing whitespace removal failed'
    strip-unicode:
      priority: 10
      glob: '*'
      exclude: "\\.(png|jpe?g|gif|webp|ico|svg|woff2?|ttf|eot|otf|mp[34]|webm|ogg|wav|flac|pdf|zip|tar|gz|xz|zst|bz2|7z|rar)$"
      run: |
        for f in {staged_files}; do
          [[ -f "$f" ]] && sed -i 's/\xE2\x80\x8B\|\xE2\x80\x8C\|\xE2\x80\x8D\|\xE2\x80\xAF\|\xC2\xAD\|\xEF\xBB\xBF//g' "$f"
        done
      stage_fixed: true
      fail_text: 'Unicode character stripping failed'
    fix-bom:
      priority: 10
      glob: '*'
      exclude: "\\.(png|jpe?g|gif|webp|ico|svg|woff2?|ttf|eot|otf|mp[34]|webm|ogg|wav|flac|pdf|zip|tar|gz|xz|zst|bz2|7z|rar)$"
      run: |
        for f in {staged_files}; do
          [[ -f "$f" ]] && LC_ALL=C sed -i '1s/^\xEF\xBB\xBF//' "$f"
        done
      stage_fixed: true
      fail_text: 'BOM removal failed'
    normalize-eol:
      priority: 11
      glob: '*.{sh,bash,zsh,yml,yaml,json,md,txt,toml,ini,conf,cfg,js,ts,tsx,jsx,css,html}'
      run: |
        for f in {staged_files}; do
          [[ -f "$f" ]] && { dos2unix -q "$f" 2>/dev/null || LC_ALL=C sed -i 's/\r$//' "$f"; }
        done
      stage_fixed: true
      fail_text: 'Line ending normalization failed'
    ensure-shebang:
      priority: 12
      glob: '*.{sh,bash}'
      run: |
        for f in {staged_files}; do
          [[ -f "$f" ]] && { { command -v rg &>/dev/null && LC_ALL=C rg -q '^#!' "$f"; } || LC_ALL=C grep -qE '^#!' "$f"; } || {
            printf '#!/usr/bin/env bash\n%s' "$(<"$f")" > "$f.tmp" && mv -f "$f.tmp" "$f"
          }
        done
      stage_fixed: true
      fail_text: 'Shebang insertion failed'
    check-executable-shebangs:
      priority: 12
      run: |
        for f in {staged_files}; do
          if [[ -f "$f" && -x "$f" ]]; then
            if command -v rg &>/dev/null; then
              LC_ALL=C rg -q '^#!' "$f" || { printf "Executable missing shebang: %s\n" "$f" >&2; exit 1; }
            else
              LC_ALL=C grep -qE '^#!' "$f" || { printf "Executable missing shebang: %s\n" "$f" >&2; exit 1; }
            fi
          fi
        done || :
      fail_text: 'Executable files must have shebangs'
    check-filesize:
      priority: 13
      run: |
        max_kb=5120
        for f in {staged_files}; do
          [[ -f "$f" ]] || continue
          size=$(stat -c%s "$f" 2>/dev/null || stat -f%z "$f" 2>/dev/null || echo 0)
          (( size > max_kb * 1024 )) && { printf "File too large: %s (%dKB, max %dKB)\n" "$f" "$((size/1024))" "$max_kb" >&2; exit 1; }
        done || :
      fail_text: 'Large files detected (>5MB)'
    check-case-conflict:
      priority: 14
      run: |
        declare -A seen
        for f in {staged_files}; do
          lower="${f,,}"
          [[ -v seen[$lower] ]] && { printf "Case conflict: %s vs %s\n" "${seen[$lower]}" "$f" >&2; exit 1; }
          seen[$lower]="$f"
        done || :
      fail_text: 'Case-insensitive filename conflict detected'
    check-symlinks:
      priority: 15
      run: |
        for f in {staged_files}; do
          [[ -L "$f" && ! -e "$f" ]] && { printf "Broken symlink: %s\n" "$f" >&2; exit 1; }
        done || :
      fail_text: 'Broken symlinks detected'
    end-of-file-fixer:
      priority: 16
      glob: '*'
      exclude: "\\.(png|jpe?g|gif|webp|ico|svg|woff2?|ttf|eot|otf|mp[34]|webm|ogg|wav|flac|pdf|zip|tar|gz|xz|zst|bz2|7z|rar)$"
      run: |
        for f in {staged_files}; do
          [[ -f "$f" && -s "$f" && -n $(tail -c1 "$f") ]] && printf '\n' >> "$f"
        done
      stage_fixed: true
      fail_text: 'End-of-file newline fix failed'
    mixed-line-ending:
      priority: 17
      glob: '*'
      exclude: "\\.(png|jpe?g|gif|webp|ico|svg|woff2?|ttf|eot|otf|mp[34]|webm|ogg|wav|flac|pdf|zip|tar|gz|xz|zst|bz2|7z|rar)$"
      run: |
        for f in {staged_files}; do
          [[ -f "$f" ]] && {
            has_crlf=$(cat "$f" | tr -cd '\r' | wc -c)
            has_lf=$(cat "$f" | tr -cd '\n' | wc -c)
            total_lines=$((has_crlf + has_lf))
            (( has_crlf > 0 && has_lf > has_crlf && total_lines > 0 )) && { printf "Mixed line endings: %s\n" "$f" >&2; exit 1; }
          }
        done || :
      fail_text: 'Mixed line endings detected'
    detect-secrets:
      priority: 18
      run: |
        if command -v rg &>/dev/null; then
          LC_ALL=C rg -iNn -e 'AKIA[0-9A-Z]{16}' -e 'ghp_[0-9a-zA-Z]{36}' -e 'glpat-[0-9a-zA-Z_-]{20,}' -e 'xox[baprs]-[0-9]{10,13}-[0-9]{10,13}-[0-9a-zA-Z]{24,}' \
            -e '(password|passwd|api[_-]?key|secret[_-]?key|access[_-]?token|auth[_-]?token|bearer|client[_-]?secret|private[_-]?key)[[:space:]]*[:=][[:space:]]*["\047][^"\047]{20,}' \
            {staged_files} && { printf "Secrets detected\n" >&2; exit 1; }
        else
          LC_ALL=C grep -EiHn -e 'AKIA[0-9A-Z]{16}' -e 'ghp_[0-9a-zA-Z]{36}' -e 'glpat-[0-9a-zA-Z_-]{20,}' \
            -e '(password|passwd|api[_-]?key|secret[_-]?key|access[_-]?token|auth[_-]?token|bearer|client[_-]?secret|private[_-]?key)[[:space:]]*[:=][[:space:]]*["\047][^"\047]{20,}' \
            {staged_files} && { printf "Secrets detected\n" >&2; exit 1; }
        fi || :
      fail_text: 'Potential secrets detected in staged files!'
    check-debug:
      priority: 19
      glob: '*.{sh,bash,js,jsx,ts,tsx,py,rb,go}'
      run: |
        if command -v rg &>/dev/null; then
          LC_ALL=C rg -iNn -e '\bconsole\.(log|debug|info|warn|error)\(' \
            -e '\bdebugger\b' -e '\bbinding\.pry\b' -e '\bset -x\b' -e '\bprint[[:space:]]*\(.*DEBUG' \
            {staged_files} && { printf "Debug code\n" >&2; exit 1; }
        else
          LC_ALL=C grep -EiHn -e '\bconsole\.(log|debug|info|warn|error)\(' \
            -e '\bdebugger\b' -e '\bbinding\.pry\b' -e '\bset -x\b' -e '\bprint[[:space:]]*\(.*DEBUG' \
            {staged_files} && { printf "Debug code\n" >&2; exit 1; }
        fi || :
      fail_text: 'Debug code found in staged files!'
    no-merge-conflicts:
      priority: 20
      run: |
        if command -v rg &>/dev/null; then
          LC_ALL=C rg -FN '^(<{7}|={7}|>{7})' {staged_files} && { printf "Merge conflicts\n" >&2; exit 1; }
        else
          LC_ALL=C grep -FHn -e '^<<<<<<<' -e '^=======' -e '^>>>>>>>' {staged_files} && { printf "Merge conflicts\n" >&2; exit 1; }
        fi || :
      fail_text: 'Merge conflict markers found!'
    check-todos:
      priority: 21
      run: |
        if command -v rg &>/dev/null; then
          count=$(rg -ic '\b(TODO|FIXME|XXX|HACK)\b' {staged_files} 2>/dev/null | awk -F: '{s+=$2}END{print s+0}')
        else
          count=$(grep -Eihc '\b(TODO|FIXME|XXX|HACK)\b' {staged_files} 2>/dev/null | awk '{s+=$1}END{print s+0}')
        fi
        (( count > 0 )) && printf "%d TODO/FIXME\n" "$count" >&2 || :
      fail_text: 'TODOs/FIXMEs found (informational)'
    actionlint:
      priority: 22
      glob: '.github/workflows/*.{yml,yaml}'
      run: 'actionlint {staged_files} || :'
      fail_text: 'GitHub Actions workflow linting failed'
    zizmor:
      priority: 23
      glob: '.github/workflows/*.{yml,yaml}'
      run: 'zizmor --format plain {staged_files} || :'
      fail_text: 'GitHub Actions security check failed'
    no-commit-to-branch:
      priority: 24
      run: |
        branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
        [[ "$branch" =~ ^(main|master)$ ]] && { printf "Direct commits to %s are not allowed\n" "$branch" >&2; exit 1; }
      fail_text: 'Cannot commit directly to protected branches (main/master)'
commit-msg:
  commands:
    conventional-commits:
      priority: 1
      run: |
        msg=$(<{1})
        if command -v rg &>/dev/null; then
          LC_ALL=C rg -q '^(feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)(\(.+\))?: .{1,}' <<< "$msg"
        else
          LC_ALL=C grep -qE '^(feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)(\(.+\))?: .{1,}' <<< "$msg"
        fi || {
          printf "Use Conventional Commits:\n  type(scope?): subject\n\nTypes: feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert\n" >&2; exit 1
        }
      fail_text: 'Commit message must follow Conventional Commits format'
    msg-length:
      priority: 2
      run: |
        subject=$(head -n1 {1})
        (( ${#subject} > 72 )) && { printf "Subject >72 chars (%d)\n" "${#subject}" >&2; exit 1; } || :
      fail_text: 'Commit subject line too long (max 72 chars)'
    no-wip:
      priority: 3
      run: |
        if command -v rg &>/dev/null; then
          LC_ALL=C rg -qi '\b(wip|todo|fixme|hack)\b' {1} && { printf "Remove WIP\n" >&2; exit 1; }
        else
          LC_ALL=C grep -qEi '\b(wip|todo|fixme|hack)\b' {1} && { printf "Remove WIP\n" >&2; exit 1; }
        fi || :
      fail_text: 'WIP/TODO/FIXME/HACK found in commit message'
pre-push:
  parallel: true
  commands:
    run-tests:
      priority: 1
      run: |
        [[ -f Makefile ]] && { make test &>/dev/null; exit 0; }
        [[ -f package.json ]] && { bun test &>/dev/null || npm test &>/dev/null; exit 0; }
        [[ -f Cargo.toml ]] && { cargo test -q &>/dev/null; exit 0; }
        [[ -f go.mod ]] && { go test ./... &>/dev/null; exit 0; }
        exit 0
      fail_text: 'Test suite failed'
    branch-check:
      priority: 2
      run: |
        branch=$(gix rev parse --abbrev-ref HEAD 2>/dev/null || git rev-parse --abbrev-ref HEAD)
        if command -v rg &>/dev/null; then
          LC_ALL=C rg -q '^(main|master|production)$' <<< "$branch" && {
            printf "Direct push to %s blocked\n" "$branch" >&2; exit 1
          }
          LC_ALL=C rg -q '^(main|master|develop|staging|release/.+|hotfix/.+|feature/.+|(bug)?fix/.+)$' <<< "$branch" || {
            printf "Use git-flow: feature/*, fix/*, release/*, hotfix/*\n" >&2
          }
        else
          LC_ALL=C grep -qE '^(main|master|production)$' <<< "$branch" && {
            printf "Direct push to %s blocked\n" "$branch" >&2; exit 1
          }
          LC_ALL=C grep -qE '^(main|master|develop|staging|release/.+|hotfix/.+|feature/.+|(bug)?fix/.+)$' <<< "$branch" || {
            printf "Use git-flow: feature/*, fix/*, release/*, hotfix/*\n" >&2
          }
        fi; exit 0
      fail_text: 'Branch naming violation or protected branch push attempt'
    audit-deps:
      priority: 3
      run: |
        [[ -f package.json ]] && { bun audit || npm audit --production --audit-level=high; } || :
        [[ -f Cargo.toml ]] && cargo audit --ignore RUSTSEC-2023-0071 || :
        exit 0
      fail_text: 'Dependency audit failed'
post-merge:
  commands:
    update-deps:
      priority: 1
      run: |
        if [[ -f bun.lockb ]]; then
          bun install --frozen-lockfile --silent --quiet--only-missing &>/dev/null
        elif [[ -f package-lock.json ]]; then
          bun install --frozen-lockfile --silent --quiet--only-missing &>/dev/null || npm ci --prefer-offline &>/dev/null
        fi
        [[ -f Cargo.lock ]] && cargo fetch &>/dev/null
        exit 0
      fail_text: 'Dependency update failed'
    clean-artifacts:
      priority: 2
      run: 'LC_ALL=C rm -rf node_modules/.cache target/debug .pytest_cache __pycache__ .next .turbo dist build || :'
      fail_text: 'Artifact cleanup failed'
post-checkout:
  commands:
    update-submodules:
      priority: 1
      run: 'LC_ALL=C submod update --init --recursive &>/dev/null || LC_ALL=C git submodule update --init --recursive &>/dev/null || :'
      fail_text: 'Submodule update failed'
    notify-deps:
      priority: 2
      run: |
        changed=$(git diff HEAD@{1} HEAD --name-only)
        if command -v rg &>/dev/null; then
          LC_ALL=C rg -q '^(package\.json|bun\.lockb|.*lock\.json)$' <<< "$changed" && {
            printf "Dependencies changed. Run: bun install\n" >&2
          }
        else
          LC_ALL=C grep -qE '^(package\.json|bun\.lockb|.*lock\.json)$' <<< "$changed" && {
            printf "Dependencies changed. Run: bun install\n" >&2
          }
        fi || :
      fail_text: 'Dependency check notification failed'
prepare-commit-msg:
  commands:
    insert-ticket:
      priority: 1
      run: |
        branch=$(LC_ALL=C gix rev parse --abbrev-ref HEAD 2>/dev/null || LC_ALL=C git rev-parse --abbrev-ref HEAD)
        [[ "$branch" =~ ^(feature|bugfix|hotfix|fix)/([A-Z]+-[0-9]+) ]] && {
          ticket="${BASH_REMATCH[2]}"
          if command -v rg &>/dev/null; then
            LC_ALL=C rg -q "$ticket" {1} || sed -i "1s/^/$ticket: /" {1}
          else
            LC_ALL=C grep -qF "$ticket" {1} || sed -i "1s/^/$ticket: /" {1}
          fi
        } || :
      fail_text: 'Ticket insertion failed'
