#!/bin/bash

mkcd() {
	#shellcheck disable=SC2164
	mkdir -p -- "$1" && cd -- "$1"
}

cdls() {
	cd -- "$1" && ls
}
cdla() {
	cd -- "$1" && ls -A
}

fs() {
	if [ "$#" -gt 0 ]; then
		du -sbh -- "$@"
	else
		# `--` is a micro-optimization.
		# these patterns work poorly with `failglob`.
		du -sbh -- .[!.]* ./* | sort -hr
	fi
}

update_git_pull() {
  if command -v git &>/dev/null; then
	local LC_ALL=C LANG=C
    git pull && git submodule update --init --recursive
  fi
}

# Bash-it sudo
function sudo-command-line() {
	[[ ${#READLINE_LINE} -eq 0 ]] && READLINE_LINE=$(fc -l -n -1 | xargs)
	if [[ $READLINE_LINE == sudo\ * ]]; then
		READLINE_LINE="${READLINE_LINE#sudo }"
	else
		READLINE_LINE="sudo $READLINE_LINE"
	fi
	READLINE_POINT=${#READLINE_LINE}
}
# Shortcut keys: [Esc] [Esc], requires astleast bash version 4
if [ "${BASH_VERSINFO[0]}" -ge 4 ]; then
	bind -x '"\e\e": sudo-command-line'
fi

# Extract various archive formats
extract() {
    if [ $# -eq 1 ]; then
        if [ -f "$1" ]; then
            echo "üì¶ Extracting $1..."
            case $1 in
                *.tar.bz2)   tar xjf "$1"     ;;
                *.tar.gz)    tar xzf "$1"     ;;
                *.bz2)       bunzip2 "$1"     ;;
                *.rar)       unrar e "$1"     ;;
                *.gz)        gunzip "$1"      ;;
                *.tar)       tar xf "$1"      ;;
                *.tbz2)      tar xjf "$1"     ;;
                *.tgz)       tar xzf "$1"     ;;
                *.zip)       unzip "$1"       ;;
                *.Z)         uncompress "$1"  ;;
                *.7z)        7z x "$1"        ;;
                *.xz)        unxz "$1"        ;;
                *.lzma)      unlzma "$1"      ;;
                *)           echo "‚ùå '$1' cannot be extracted (unsupported format)" ;;
            esac
            echo "‚úÖ Extraction complete"
        else
            echo "‚ùå '$1' is not a valid file"
        fi
    else
        echo "Usage: extract <archive_file>"
    fi
}

# Find and kill processes (with confirmation)
pk() {
    if [ $# -eq 1 ]; then
        local pids=$(ps aux | grep "$1" | grep -v grep | awk '{print $2}')
        if [ -n "$pids" ]; then
            echo "üîç Found processes matching '$1':"
            ps aux | grep "$1" | grep -v grep
            echo -n "‚ùì Kill these processes? (y/N): "
            read -r confirm
            if [[ $confirm =~ ^[Yy]$ ]]; then
                echo "$pids" | xargs kill -9
                echo "üíÄ Processes killed"
            else
                echo "‚ùå Cancelled"
            fi
        else
            echo "‚ùå No processes found matching '$1'"
        fi
    else
        echo "Usage: pk <process_name>"
    fi
}

# Quick directory creation and navigation
mkcd() {
    if [ $# -eq 1 ]; then
        mkdir -p "$1" && cd "$1"
        echo "üìÅ Created and entered directory: $1"
    else
        echo "Usage: mkcd <directory_name>"
    fi
}

# Delete merged/gone branches
alias gdbr="git fetch --prune && git branch -vv | grep ': gone]' | awk '{print \$1}' | xargs -r git branch -D"
# Enhanced git branch view with better formatting
alias gbr="git branch --format='%(HEAD) %(color:yellow)%(refname:short)%(color:reset) - %(contents:subject) %(color:green)(%(committerdate:relative)) [%(authorname)]' --sort=-committerdate"

# Sudo wrapper
# 	G_SUDO(){ local input=$*; sudo bash -c ". /boot/dietpi/func/dietpi-globals && $input"; }
G_SUDO(){ local input=$*; sudo bash -c "$input"; }

# delete empty subdirs
__prune() {
  if [[ -n "$1" ]]; then
    read -r "reply?Prune empty directories: are you sure? [y] "
  else
    local _reply=y
  fi

  [[ "$_reply" = y ]] && find . -type d -empty -delete
}
__prune "$@"

alias yayf="yay -Slq | fzf --multi --preview 'yay -Sii {1}' --preview-window=down:75% | xargs -ro yay -S"

vid2gif() {
  local video_path="$1"
  ffmpeg \
	  -i "$video_path" \
	  -r 15 \
	  -vf scale=512:-1 \
	  "$video_path.gif"
}

list_opened_apps() { ps axc | awk 'NR > 1' | awk '{print substr($0,index($0,$5))}' | sort -u }

diff() {
  if exists diff-so-fancy; then
    command diff -u "$@" | diff-so-fancy | less -RF
  elif exists colordiff; then
    command diff -u "$@" | colordiff | less -RF
  else
  command diff -u "$@" | less -RF
fi
}

murder() (
  ps aux | grep -i "$1" | awk '{print $2}' | xargs kill -9
}

bgd(){ (nohup "$@" >/dev/null 2>&1 < /dev/null & disown); }
bgd_full(){ (nohup setsid "$@" >/dev/null 2>&1 < /dev/null & disown); }


shortenPath(){
	# GET PARAMETERS
	local path=$1 max_length=$2 default_max_length=25 trunc_symbol=${3:-"‚Ä¶"}
  # CHECK PARAMETERS AND INIT
	if   [ -z "$path" ]; then
		echo ""; exit
	elif [ -z "$max_length" ]; then
		local max_length=$default_max_length
	fi
	# CLEANUP PATH
	# Replace HOME with ~ for the current user, similar to sed.
	local path=${path/#$HOME/\~}
	# Get curred directory (last folder in path) to get its length (num characters).
	# Determine the actual max length we will use to truncate, choosing between either
  # $max_length, set by the usert, or the length of the current dir,
  # depending on which is greater. This ensures that even if we set a
  # relatively  low $max_length value, the name of the current dir will not
  # be truncated. Store in $print_length
	local dir=${path##*/} dir_length=${#dir} path_length=${#path} print_length=$(( ( max_length < dir_length ) ? dir_length : max_length ))
  # TRUNCATE PATH TO
	# If $path_length > $print_lenght
	#	Truncate the path to max_length
	#	Clean off path fragments before first '/' (included)
  # Check if the bit we have removed would have landed at home
  # If at home, prepend '~' to the clean path, Else, prepend the "trunc_symbol" to the clean path
	if [ $path_length -gt $print_length ]; then
		local offset=$(( $path_length - $print_length )) truncated_path=${path:$offset} clean_path="/${truncated_path#*/}" removed_path=${path%%"$clean_path"}
    if [ "$removed_path" == "~" ]; then
      local short_path="~${clean_path}"
    else
      local short_path=${trunc_symbol}${clean_path}
    fi
	else
    local short_path=$path
	fi
	echo $short_path
}

fiximg() {
  local IM IDENTIFY exts
  # pick the right ImageMagick binary
  if command -v magick &>/dev/null; then
    IM="magick convert"
    IDENTIFY="magick identify"
  else
    IM="convert"
    IDENTIFY="identify"
  fi
  local -a exts=(png jpg jpeg webp avif jxl)
  strip_file() {
    local f="$1" tmp
    # check if file has metadata
    if [[ -n $($IDENTIFY -format "%[EXIF:*]" "$f" 2>/dev/null) ]] || \
       [[ -n $($IDENTIFY -format "%[IPTC:*]" "$f" 2>/dev/null) ]] || \
       [[ -n $($IDENTIFY -format "%[Comment]" "$f" 2>/dev/null) ]]; then
      tmp="${f}.strip.$$"
      $IM "$f" -strip "$tmp" && mv "$tmp" "$f"
    fi
  }
  if command -v fd &>/dev/null; then
    fd -t f $(printf -- '-e %s ' "${exts[@]}") -x bash -c 'for f; do strip_file "$f"; done' _ {}
  elif command -v fdfind &>/dev/null; then
    fdfind -t f $(printf -- '-e %s ' "${exts[@]}") -x bash -c 'for f; do strip_file "$f"; done' _ {}
  else
    find . -type f \( $(printf -- '-iname "*.%s" -o ' "${exts[@]}") -false \) -print0 |
      xargs -0 -n1 -P"$(nproc)" bash -c 'for f; do strip_file "$f"; done' _
  fi
}
